# (PART) Get Started {-}

```{r, include = FALSE}
source("common.R")
```

# R Quickstart {-}

This section requires the next libraries:

```{r}
library(rgee)
library(rgeeExtra)

ee_Initialize()
```


## Get Started with Earth Engine {-}

This Get Started guide is intended as a quick way to start programming with the Earth Engine R API. For an introductory look at R and more in-depth exercises with the Earth Engine API, see the [tutorials]( ). For recommended R coding style, see the [R Style Guide]( ).

Google Earth Engine allows users to run algorithms on georeferenced imagery and vectors stored on Google's infrastructure. The Google Earth Engine API provides a library of functions which may be applied to data for display and analysis. Earth Engine's [public data catalog](https://developers.google.com/earth-engine/datasets) contains a large amount of publicly available imagery and vector datasets. Private assets can also be created in users' personal folders.

## How to use these docs {-}

The Earth Engine documentation is designed for people familiar with geospatial data analysis. The docs are primarily structured by data type. For example, the left side navigation contains links to sections or pages about important data types such as [Image](), [ImageCollection](), [Feature](), [FeatureCollection](), [Geometry](), [Reducer](), [Join]() and [Array](). This guide only describes only enough about these types to get you started. There are also sections for [machine learning](), specialized or sensor specific algorithms (e.g. [Landsat algorithms]()), [public facing apps]() with shinyapps.io and important details about [Earth Engine internal workings](). Before diving in to any of that, start here!

## Earth Engine data structures {-}

The two most fundamental geographic data structures in Earth Engine are [Image]() and [Feature]() corresponding to raster and vector data types, respectively. Images are composed of bands and a list of properties. Features are composed of a [Geometry]() and a list of properties. A stack of images (e.g. an image time series) is handled by an [ImageCollection](). A collection of features is handled by a [FeatureCollection](). Other fundamental data structures in Earth Engine include `List`, `Array`, `Date`, `Number` and `String` (learn more about basic data types from [this tutorial](). It is important to remember that these are all server-side objects and are not manipulated the same way as client-side R objects are ([learn more]()).

## Earth Engine algorithms {-}

There are several ways to run operations in the API:

- Calling methods that are attached to objects.
- Calling algorithms.
- Calling rgee specific functions.
- Defining new functions.

Use the [`rgee Rstudio addins`](`) for get access to the documentation. For example, the `Image` class has an `add()` method:

### Using rgee {-}

```{r, eval=FALSE}
image3 <- image1$add(image2)
```

### Using rgeeExtra {-}

```{r, eval=FALSE}
image3 <- image1 + image2
```


This method adds the bands of `image2` to the bands of `image1`. The `ee$Algorithms` category contains a list of currently supported algorithms for specialized or domain specific processing. For example, to create topographic layers from an input Digital Elevation Model (DEM):

```{r, eval=FALSE}
terrainImage <- ee$Algorithms$Terrain(dem)
```

rgee specific functions include the `Map` and `ee$batch$Export` methods, which control how layers are added to the map panel or exported to Google Drive, respectively. Functions can also be created in R using

```{r}
myFunction <- function(args) {
  # do something
  return(something)
}
```

As illustrated in the [Mapping section](), user defined functions are useful for creating custom functionality or modifying the elements of a collection using:

```{r}
collection2 <- collection1$map(aFunction)
```


The following sections illustrate these concepts for various simple use cases.

*Notation used in the guides:*

Static methods called on an Earth Engine class (for example `ee$Image`) are written as `Image$staticMethod()`. Methods called on an instance of a class are written as `image$instanceMethod()`. The lowercase image means that a variable named image refers to an instance of the `ee$Image` class.

## 'Hello World' - R {-}

Printing out information to the console is a basic task for getting information about an object, displaying the numeric result of a computation, displaying object metadata or helping with debugging. The iconic ‘Hello World!’ example in R is:

```{r, eval=FALSE}
print('Hello world!')
```

Copy this line into the RStudio Code Editor and click Run. Note that the output is displayed in the Console tab. For a more remote sensing relevant example, the following prints the metadata of a Landsat 8 image:

```{r, eval=FALSE}
img <- ee$Image('LANDSAT/LC08/C01/T1/LC08_044034_20140318')
ee_print(img)
```

Carefully inspect the output in the console to see metadata available for Landsat images.

## Adding data to the map {-}

In addition to printing information to the console, adding data to the Map is the way to visualize geographic data. Use `Map$addLayer()` to do that. In the following example, an Image is instantiated (how to find these images is covered later) using `ee$Image()`, added to the map with `Map$addLayer()` and the map is centered over the image:

```{r, eval=FALSE}
## Load an image.
image <- ee$Image('LANDSAT/LC08/C01/T1/LC08_044034_20140318')

## Center the map on the image.
Map$centerObject(image, 9)

## Display the image.
Map$addLayer(image)
```

<center>
<img src="images/chapter_01/figure_map_01.png">
</center>
<br>
The second parameter of `Map$centerObject()` is a zoom level, where higher numbers indicate larger scale (more zoomed in). The parameters for the `Map` functions are described in depth in rgee documentation: `help(Map)` or `help(R6Map)`. If the appearance of the image is unsatisfactory, configure the display parameters with an additional argument to `Map$addLayer()`. For example:

```{r, eval=FALSE}
## Load the image from the archive.
image <- ee$Image('LANDSAT/LC08/C01/T1/LC08_044034_20140318')

## Define visualization parameters in an object literal.
vizParams <- list(
  bands = c('B5', 'B4', 'B3'),
  min = 5000, 
  max = 15000, 
  gamma = 1.3
)

## Center the map on the image and display.
Map$centerObject(image, 9)
Map$addLayer(image, vizParams, 'Landsat 8 false color')
```

<center>
<img src="images/chapter_01/figure_map_02.png">
</center>
<br>

Observe that the visualization parameters are defined by an object literal, which includes a list of bands to display, a minimum and maximum digital number and a gamma value. (Learn more about Landsat bands [here](). Learn more about image visualization [here]()).

Use `Map$addLayer()` to add features and feature collections to the map. For example,

```{r, eval=FALSE}
counties <- ee$FeatureCollection('TIGER/2016/Counties')
Map$addLayer(counties, {},'counties')
```

<center>
<img src="images/chapter_01/figure_map_03.png">
</center>
<br>

## Finding images, image collections and feature collections {-}

Images, image collections, and feature collections are discoverable by searching the Earth Engine Data Catalog. For example, entering ‘Landsat 8’ into the search field results in a list of raster datasets. (The complete listing of Earth Engine datasets is at the [Earth Engine Data Catalog](https://developers.google.com/earth-engine/datasets)). In rgee we add an special attribute `Dataset` to `ee$Image`, `ee$ImageCollection`, and `ee$FeatureCollections` objects. Use `...$Dataset` to easy get access to the EE Data Catalog.


```{r}
ee$Image$Dataset$...
ee$ImageCollection$Dataset$...
ee$FeatureCollection$Dataset$...
```

Search into the Earth Engine Data Catalog

```{r}
ee$Image$Dataset$USGS_SRTMGL1_003 %>% 
  ee_utils_dataset_display()
```

Alternatively, copy the collection ID and paste it into your code. For example, choose the first result of the ‘Landsat 8’ search and copy the ID as follows:

```{r, eval=FALSE}
collection <- ee$ImageCollection('LANDSAT/LC08/C01/T1')
```

Since this is a collection of many images spanning the Earth land surface, finding an individual image in the collection requires filtering in order to narrow down the search. Alternatively, the collection of images can be reduced to a single image using compositing and mosaicking techniques. More on filtering and compositing (see [Reducing]()) in the next sections.

Feature collections are also available through the Data Catalog. Their representation is smaller than image collections, but you will find international, census, watershed, and protected areas boundaries, to name a few. Learn more about importing your own vector datasets [here]().

## Filtering and Sorting {-}

It is often necessary to filter a collection by space and/or time in order to limit the number of results. For example, consider the task of sorting the Landsat 8 scene collection in order to find a cloud-free scene for San Francisco. First, it is necessary to define the region of interest. A point is often useful for that. Press `Ctrl` and click near the center of your area of interest, it will atuomatically copy the coordinates, then construct a `ee$Point` using:


<center>
<img src="images/chapter_01/figure_map_04.png">
</center>
<br>


```{r, eval=FALSE}
" lon: -118.12500 | lat: 63.52866 | zoom: 1 "
point <- ee$Geometry$Point(-118.12500, 63.52866)
```

Construct start and end dates:

```{r, eval=FALSE}
start <- ee$Date('2014-06-01')
finish <- ee$Date('2014-10-01')
```

Filter the Landsat 8 collection using the point and the dates, then sort using a metadata property (discovered during inspection of the Landsat 8 scene metadata):

```{r, eval=FALSE}
filteredCollection <- ee$ImageCollection("LANDSAT/LC08/C01/T1") %>% 
  ee$ImageCollection$filterDate(start, finish) %>% 
  ee$ImageCollection$filterBounds(point) %>% 
  ee$ImageCollection$sort('CLOUD_cOVER')
```

This collection can be safely inspected using ``ee_print`. (If the collection has too many images, printing it will either be very slow, time out, or return an error). Observe that the images in the collection are a `List` stored in the ‘features’ property of the `ImageCollection`. The ID of any image in the collection can be copied into the `Image` constructor as above. Alternatively, get the first image (lowest cloud cover):


### using rgee {-}

```{r, eval=FALSE}
first <- filteredCollection$first()
```

### using rgeeExtra {-}

```{r, eval=FALSE}
first <- filteredCollection[[1]]
```

Access the complete Earth Engine filtering functionality using `filter()` with an `ee$Filter` as the argument. (The `filterBounds()` and `filterDate()` methods used above are shortcuts). For example, the following creates a `Filter`, uses it to filter a `FeatureCollection` and displays the result:

```{r, eval=FALSE}
## Load a feature collection.
featureCollection <- ee$FeatureCollection('TIGER/2016/States')

## Filter the collection.
filteredFC <- featureCollection %>% 
  ee$FeatureCollection$filter(
    ee$Filter$eq('NAME', 'California')
  )

## Display the collection.
Map$addLayer(filteredFC, {}, 'California')
```

<center>
<img src="images/chapter_01/figure_map_05.png">
</center>
<br>

## Band math {-}

Perform mathematical operations on images using `Image` methods. This may include band recombinations (spectral indices), image differencing or mathematical operations such as multiplication by a constant. For example, compute the difference between Normalized Difference Vegetation Index (NDVI) images 20 years apart:

### using rgee {-}

```{r, eval=FALSE}
## This function gets NDVI from Landsat 5 imagery.
getNDVI <- function(image) {
  return(image$normalizedDifference('B4', 'B3'))
}

## Load two Landsat 5 images, 20 years apart.
image1 = ee$Image('LANDSAT/LT05/C01/T1_TOA/LT05_044034_19900604')
image2 = ee$Image('LANDSAT/LT05/C01/T1_TOA/LT05_044034_20100611')

## Compute NDVI from the scenes.
ndvi1 = getNDVI(image1)
ndvi2 = getNDVI(image2)

## Compute the difference in NDVI.
ndviDifference = ndvi2$subtract(ndvi1)
```

### using rgeeExtra {-}

```{r, eval=FALSE}
## This function gets NDVI from Landsat 5 imagery.
getNDVI <- function(image) {
  (image[["B4"]] - image[["B3"]])/(image[["B4"]] + image[["B3"]])
}

## Load two Landsat 5 images, 20 years apart.
image1 <- ee$Image('LANDSAT/LT05/C01/T1_TOA/LT05_044034_19900604')
image2 <- ee$Image('LANDSAT/LT05/C01/T1_TOA/LT05_044034_20100611')

## Compute NDVI from the scenes.
ndvi1 <- getNDVI(image1)
ndvi2 <- getNDVI(image2)

## Compute the difference in NDVI.
ndviDifference = ndvi2 - ndvi1
```

Notice the use of a user defined `function` in this example. More on functions in the next section.

## Mapping (what to do instead of a for-loop) {-}

Use `map()` to iterate over items in a collection. (For loops are NOT the right way to do that in Earth Engine and should be avoided). The `map()` function can be applied to an `ImageCollection`, a `FeatureCollection` or a `List` and accepts a function as its argument. The argument of the function is an element of the collection over which it is mapped. This is useful for modifying every element of the collection in the same way, for example adding. For example, the following code adds an NDVI band to every image in an `ImageCollection`:

### Using rgee {-}

```{r, eval=FALSE}
## This function gets NDVI from Landsat 8 imagery.
addNDVI <- function(image) {
  return(image$addBands(image$normalizedDifference('B5', 'B4')))
}

## Load the Landsat 8 raw data, filter by location and date.
ee_geom <- ee$Geometry$Point(-122.262, 37.8719)
collection <- ee$ImageCollection('LANDSAT/LC08/C01/T1') %>% 
  ee$ImageCollection$filterBounds(ee_geom) %>% 
  ee$ImageCollection$filterDate('2014-06-01', '2014-10-01')

## Map the function over the collection.
ndviCollection <- collection$map(addNDVI)
```

### Using rgeeExtra {-}

```{r, eval=FALSE}
## This function gets NDVI from Landsat 8 imagery.
addNDVI <- function(image) {
  ndvi <- (image[["B5"]] - image[["B4"]])/(image[["B5"]] + image[["B4"]])
  image$addBands(ndvi)
}

## Load the Landsat 8 raw data, filter by location and date.
ee_geom <- ee$Geometry$Point(-122.262, 37.8719)
collection <- ee$ImageCollection('LANDSAT/LC08/C01/T1') %>% 
  ee$ImageCollection$filterBounds(ee_geom) %>% 
  ee$ImageCollection$filterDate("2014-06-01", "2014-10-01")

## Map the function over the collection.
ndviCollection <- collection$map(addNDVI)
```

Another common task is adding a new property (or ‘attribute’ or ‘field’) to features in a `FeatureCollection`. In the following example, the new property is a computation involving two existing attributes:

```{r, eval=FALSE}
## This function creates a new property that is the sum of two existing properties.
addField <- function(feature) {
  sum <- ee$Number(feature$get('property1'))$add(feature$get('property2'))
  feature$set(sum = sum)
}

## Create a FeatureCollection from a list of Features.
features <- ee$FeatureCollection(c(
  ee$Feature(ee$Geometry$Point(-122.4536, 37.7403),
    list(property1 = 100, property2 = 100)),
  ee$Feature(ee$Geometry$Point(-118.2294, 34.039),
    list(property1 = 200, property2 = 200))
))
## Map the function over the collection.
featureCollection <- features$map(addField)

## Print a selected property of one Feature.
print(featureCollection$first()$get('sum')$getInfo())

## Print the entire FeatureCollection.
ee_print(featureCollection)
```

Note the cast to `ee$Number` required for the property value to be recognized as a number in order to use the `add()` method. The type of the collection can be changed by `map()`. For example:

```{r, eval=FALSE}
## This function returns the image centroid as a new Feature.
getGeom <- function(image) {
  ee$Feature(image$geometry()$centroid(), list(foo = 1))
}

## Load a Landsat 8 collection.
ee_geom <- ee$Geometry$Point(-122.262, 37.8719)
collection <- ee$ImageCollection('LANDSAT/LC08/C01/T1') %>% 
  ee$ImageCollection$filterBounds(ee_geom) %>% 
  ee$ImageCollection$filterDate('2014-06-01', '2014-10-01')

## Map the function over the ImageCollection.
featureCollection <- ee$FeatureCollection(collection$map(getGeom))

## Print the collection.
ee_print(featureCollection)
```

Note the added property (`foo`) for each feature created from the image centroid. In the final line, the cast makes the resultant collection recognizable as a `FeatureCollection`.

## Reducing {-}

Reducing is the way to aggregate data over time, space, bands, arrays and other data structures in Earth Engine. Various methods exist for this purpose in the API. For example, to make a composite of an `ImageCollection`, use `reduce()` to reduce the images in the collection to one Image. A simple example is creating the median composite of the five least cloudy scenes in the Landsat 8 collection defined earlier:

```{r}
## Load a Landsat 8 collection.
collection <- ee$ImageCollection('LANDSAT/LC08/C01/T1') %>% 
  ## Filter by date and location.
  ee$ImageCollection$filterBounds(ee$Geometry$Point(-122.262, 37.8719)) %>% 
  ee$ImageCollection$filterDate('2014-01-01', '2014-12-31') %>% 
  ## Sort by increasing cloudiness.
  ee$ImageCollection$sort('CLOUD_COVER')
```

### Using rgee {-} 

```{r, eval=FALSE}
## Compute the median of each pixel for each band of the 5 least cloudy scenes.
median <- collection$limit(5)$reduce(ee$Reducer$median())
```

### Using rgeeExtra {-}

```{r, eval=FALSE}
## Compute the median of each pixel for each band of the 5 least cloudy scenes.
median <- collection[[1:5]]$reduce(ee$Reducer$median())
```

Reducing is also the way to get statistics of an image in the regions defined by a `Feature` or `FeatureCollection`. Suppose the task is to compute the mean pixel values within an area of interest. Use `reduceRegion()` for this purpose. For example:

```{r, eval=FALSE}
## Load and display a Landsat TOA image.
image <- ee$Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')

## Create an arbitrary rectangle as a region and display it.
region <- ee$Geometry$Rectangle(-122.2806, 37.1209, -122.0554, 37.2413)

## Get a dictionary of means in the region.  Keys are bandnames.
mean <- image$reduceRegion(
  reducer = ee$Reducer$mean(),
  geometry = region,
  scale = 30
)

Map$addLayer(
  eeObject = image,
  visParams = list(bands = c("B4", "B3", "B2"), max = 0.5), 
  name = "SF"
) + 
Map$addLayer(region, list(color="red"), name = "ROI")
```

<center>
<img src="images/chapter_01/figure_map_06.png">
</center>
<br>

Learn more about reducers from the [Reducers doc]().

## Masking {-}

Every pixel in an `ee$Image` has both a value and a mask which ranges from 0 (no data) to 1. Masked pixels (in which mask == 0) are treated as no data. Pixels with 0 < mask ≤ 1 have a value, but it is weighted by the mask for numerical computations.

You can make pixels transparent or exclude them from analysis using masks. Pixels are masked when the mask value is zero. Continuing the image differencing example, use a mask to display areas of increased and decreased NDVI over the difference interval:

### Using rgee {-}

```{r, eval=FALSE}
## This function gets NDVI from Landsat 5 imagery.
getNDVI <- function(image) {
  image$normalizedDifference(c('B4', 'B3'))
}

## Load two Landsat 5 images, 20 years apart.
image1 <- ee$Image('LANDSAT/LT05/C01/T1_TOA/LT05_044034_19900604')
image2 <- ee$Image('LANDSAT/LT05/C01/T1_TOA/LT05_044034_20100611')

## Compute NDVI from the scenes.
ndvi1 <- getNDVI(image1)
ndvi2 <- getNDVI(image2)

## Compute the difference in NDVI.
ndviDifference = ndvi2$subtract(ndvi1)
## Load the land mask from the SRTM DEM.
landMask <- ee$Image('CGIAR/SRTM90_V4')$mask()

## Update the NDVI difference mask with the land mask.
maskedDifference <- ndviDifference$updateMask(landMask)

## Display the masked result.
vizParams <- list(
  min = -0.5, 
  max = 0.5, 
  palette = c('FF0000', 'FFFFFF', '0000FF')
)
Map$setCenter(-122.2531, 37.6295, 9)
Map$addLayer(maskedDifference, vizParams, 'NDVI difference')
```

### Using rgeeExtra {-}

```{r}
## This function gets NDVI from Landsat 5 imagery.
getNDVI <- function(image) {
  (image[["B4"]] - image[["B3"]])/(image[["B4"]] + image[["B3"]])
}

## Load two Landsat 5 images, 20 years apart.
image1 <- ee$Image('LANDSAT/LT05/C01/T1_TOA/LT05_044034_19900604')
image2 <- ee$Image('LANDSAT/LT05/C01/T1_TOA/LT05_044034_20100611')

## Compute NDVI from the scenes.
ndvi1 <- getNDVI(image1)
ndvi2 <- getNDVI(image2)

## Compute the difference in NDVI.
ndviDifference <- ndvi2 - ndvi1

## Load the land mask from the SRTM DEM.
landMask <- ee$Image('CGIAR/SRTM90_V4')$mask()

## Update the NDVI difference mask with the land mask.
maskedDifference <- ndviDifference$updateMask(landMask)

## Display the masked result.
vizParams <- list(
  min = -0.5, 
  max = 0.5, 
  palette = c('FF0000', 'FFFFFF', '0000FF')
)
Map$setCenter(-122.2531, 37.6295, 9)
Map$addLayer(maskedDifference, vizParams, 'NDVI difference')
```

<center>
<img src="images/chapter_01/figure_map_07.png">
</center>
<br>

In this example, note that the mask of the NDVI difference is updated by the land mask with `updateMask()`. This sets the mask of the NDVI difference pixels to the land mask wherever the NDVI difference mask is non-zero.

Masking is also useful for excluding data from the analysis. Consider the `reduceRegion()` example from the [Reducing section](). Suppose the task is to compute a seasonal mean NDVI for Santa Clara county, CA, excluding cloudy pixels. The following example demonstrates multiple concepts: filtering, mapping, reducing and the use of a cloud mask:

```{r, eval=FALSE}
## This function gets NDVI from a Landsat 8 image.
addNDVI <- function(image) {
  return(image$addBands(image$normalizedDifference(c('B5', 'B4'))))
}

## This function masks cloudy pixels.
cloudMask <- function(image) {
  clouds <- ee$Algorithms$Landsat$simpleCloudScore(image)$select('cloud')
  return(image$updateMask(clouds$lt(10)))
}

## Load a Landsat collection, map the NDVI and cloud masking functions over it.
ee_geom <- ee$Geometry$Point(-122.262, 37.8719)
collection <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA') %>% 
  ee$ImageCollection$filterBounds(ee_geom) %>% 
  ee$ImageCollection$filterDate('2014-03-01', '2014-05-31') %>% 
  ee$ImageCollection$map(addNDVI) %>% 
  ee$ImageCollection$map(cloudMask)

## Reduce the collection to the mean of each pixel and display.
meanImage <- collection$reduce(ee$Reducer$mean())
vizParams <- list(
  bands = c('B5_mean', 'B4_mean', 'B3_mean'),
  min = 0, 
  max = 0.5)


## Load a region in which to compute the mean and display it.
counties <- ee$FeatureCollection('TIGER/2016/Counties')
santaClara <- ee$Feature(counties$filter(ee$Filter$eq('NAME', 'Santa Clara'))$first())

## Get the mean of NDVI in the region.
mean <- meanImage$select('nd_mean')$reduceRegion(
  reducer = ee$Reducer$mean(),
  geometry = santaClara$geometry(),
  scale = 30
)

## Print mean NDVI for the region.
print('Santa Clara spring mean NDVI:', mean$get('nd_mean')$getInfo())


# Display maps
Map$addLayer(meanImage, vizParams, 'mean') +
Map$addLayer(santaClara)
```

<center>
<img src="images/chapter_01/figure_map_08.png">
</center>
<br>

# Coding Best Practices {-}

This section requires the next libraries:

```{r}
library(rgee)

ee_Initialize()
```


<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
<style type="text/css">
  body{
    font-size: 15pt;
    font-family: 'Roboto', sans-serif;
  }
  pre code{
    font-size: 12pt;
  }
  .list-group-item:last-child{
    font-size: 11pt;
    font-weight: bold;
  }
</style>


This doc describes coding practices that are intended to maximize the chance of success for complex or expensive Earth Engine computations. 

## **Avoid mixing client functions and objects with server functions and objects** {-}

Earth Engine server objects are objects with constructors that start with `ee` (e.g. ee\$Image, ee\$Reducer) and any methods on such objects are server functions. Any object not constructed in this manner is a client object. Client objects may come from the R Earth Engine client (e.g. Map) or the R language (e.g. date, data.frame, c(), list()).

To avoid unintended behavior, do not mix client and server functions in your script as discussed [here](https://developers.google.com/earth-engine/guides/debugging). See [this page](https://developers.google.com/earth-engine/guides/client_server) for in-depth explanation of client vs. server in Earth Engine. The following example illustrates the dangers of mixing client and server functionality:


<img src="images/thumb_down.png" width=25px>
&nbsp; **Error** — This code doesn't work!



```{r}
# Won't work.
for (i in seq_len(table$size())) {
  print('No!') 
}
```


Can you spot the error? Note that `table$size()` is a server method on a server
object and can not be used with client-side functionality such as the `seq_len` function.

A situation in which you may want to use for-loops is with to display results 
with `Map`, since the Map object and methods are client-side.

<img src="images/thumb_up.png" width=25px>
&nbsp; **Good** — Use client functions for display Earth Engine spatial objects.


```{r}
l8_ts <- sprintf(
  "LANDSAT/LC08/C01/T1/LC08_044034_%s",
  c("20140318", "20140403","20140419","20140505")
)
display_l8ts <- list()
for (l8 in l8_ts) {
  ee_l8 <- ee$Image(l8)
  display_l8ts[[l8]] <- Map$addLayer(ee_l8)
}
Map$centerObject(ee_l8)
Reduce('+', display_l8ts)
```

Conversely, `map()` is a server function and client functionality won't work 
inside the function passed to map(). For example:

<img src="images/thumb_down.png" width=25px>
&nbsp; **Error** — This code doesn't work!

```{r}
table <- ee$FeatureCollection('USDOS/LSIB_SIMPLE/2017')
# Error:
foobar <- table$map(function(f) {
  print(f); # Can't use a client function here.
  # Can't Export, either.
})
```

<img src="images/thumb_up.png" width=25px>
&nbsp; **Good** — Use `map()` `set()`.

```{r}
table <- ee$FeatureCollection('USDOS/LSIB_SIMPLE/2017')
# Do something to every element of a collection.
withMoreProperties = table$map(function(f) {
  # Set a property.
  f$set("area_sq_meters", f$area())
})
print(withMoreProperties$first()$get("area_sq_meters")$getInfo())
```

You can also `filter()` the collection based on computed or existing properties 
and `print()` the result. Note that you can not print a collection with more 
5000 elements. If you get the "Collection query aborted after accumulating over
5000 elements" error, `filter()` or `limit()` the collection before printing.


## **Avoid converting to list unnecessarily** {-}

Collections in Earth Engine are processed using optimizations that are broken by converting the collection to a `List` or `Array` type. Unless you need random access to collection elements (i.e. you need to get the i'th element of a collection), use filters on the collection to access individual collection elements. The following example illustrates the difference between type conversion (not recommended) and filtering (recommended) to access an element in a collection:

<img src="images/thumb_down.png" width=25px>
&nbsp; **Bad** — Don't convert to list unnecessarily!

```{r}
table <- ee$FeatureCollection('USDOS/LSIB_SIMPLE/2017');
# Do NOT do this!!
list <- table$toList(table$size())
print(list$get(13)$getInfo()) # User memory limit exceeded.
```

Note that you can easily trigger errors by converting a collection to a list unnecessarily. The safer way is to use `filter()`:

<img src="images/thumb_up.png" width=25px>
&nbsp; **Good** — Use `filter()`.

```{r}
print(table$filter(ee$Filter$eq('country_na', 'Niger'))$first()$getInfo())
```

Note that you should [use filters as early as possible in your analysis](https://developers.google.com/earth-engine/guides/best_practices).

## **Avoid ee.Algorithms.If()** {-}

Do not use `ee.Algorithms.If()` to implement branching logic, especially in a mapped function. As the following example illustrates, `ee.Algorithms.If()` can be memory intensive and is not recommended:

<img src="images/thumb_down.png" width=25px>
&nbsp; **Bad** — Don't use `If()`:

```{r}
table <- ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')
# Do NOT do this!
veryBad = table$map(function(f) {
  ee$Algorithms$If(
    condition = ee$String(f$get('country_na'))$compareTo('Chad')$gt(0),
    trueCase = f,      # Do something.
    falseCase = NULL   # Do something else.
  )
}, TRUE)
print(veryBad$getInfo()) # User memory limit exceeded.
# If() may evaluate both the true and false cases.
```


Note that the second argument to `map()` is `TRUE`. This means that the mapped 
function may return nulls and they will be dropped in the resultant collection. 
That can be useful (without `If()`), but here the easiest solution is to use a
filter:

<img src="images/thumb_up.png" width=25px>
&nbsp; **Good** — Use `filter()`.

```{r}
print(table$filter(ee$Filter$eq('country_na', 'Chad')))
```

As shown in [this tutorial](https://developers.google.com/earth-engine/tutorials/tutorial_js_03), a functional programming approach using filters is the correct way to apply one logic to some elements of a collection and another logic to the other elements of the collection.

## **Avoid reproject()** {-}

Don't use `reproject` unless absolutely necessary. One reason you might want to use reproject() is to force `Map` display computations to happen at a specific scale so you can examine the results at your desired scale of analysis. In the next example, patches of hot pixels are computed and the count of pixels in each patch is computed. Run the example and click on one of the patches. Note that the count of pixels differs between the reprojected data the data that has not been reprojected.

```{r}
l8sr <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")
sf <- ee$Geometry$Point(c(-122.405, 37.786))
Map$centerObject(sf, 13)
# A reason to reproject - counting pixels and exploring interactively.
image <- l8sr$filterBounds(sf)$
  filterDate("2019-06-01", "2019-12-31")$
  first()
Map$addLayer(image, list(bands = "B10", min = 2800, max = 3100), "image")
hotspots <- image$select("B10")$
  gt(3100)$
  selfMask()$
  rename("hotspots")
objectSize <- hotspots$connectedPixelCount(256)
# Beware of reproject!  Don't zoom out on reprojected data.
reprojected <- objectSize$reproject(hotspots$projection())
Map$addLayer(objectSize, list(min = 1, max = 256), "Size No Reproject", FALSE) +
Map$addLayer(reprojected, list(min = 1, max = 256), "Size Reproject", FALSE)
```

The reason for the discrepancy is because the [scale of analysis](https://developers.google.com/earth-engine/guides/scale) is set by the Code Editor zoom level. By calling `reproject()` you set the scale of the computation instead of the Map display. Use `reproject()` with extreme caution for reasons described in [this doc](https://developers.google.com/earth-engine/guides/projections).


## **Filter and select() first** {-}

In general, filter input collections by time, location and/or metadata prior to doing anything else with the collection. Apply more selective filters before less selective filters. Spatial and/or temporal filters are often more selective. For example, note that `select()` and `filter()` are applied before `map()`:

```{r}
images <- ee$ImageCollection("COPERNICUS/S2_SR")
sf <- ee$Geometry$Point(c(-122.463, 37.768))
# Expensive function to reduce the neighborhood of an image.
reduceFunction <- function(image) {
  image$reduceNeighborhood(
    reducer = ee$Reducer$mean(),
    kernel = ee$Kernel$square(4)
  )
}
bands <- list("B4", "B3", "B2")
# Select and filter first!
reasonableComputation <- images$select(bands)$
  filterBounds(sf)$
  filterDate("2018-01-01", "2019-02-01")$
  filter(ee$Filter$lt("CLOUDY_PIXEL_PERCENTAGE", 1))$
  aside(ee_print)$ # Useful for debugging.
  map(reduceFunction)$
  reduce('mean')$
  rename(bands)
viz <- list(bands = bands, min = 0, max = 10000)
Map$addLayer(reasonableComputation, viz, "resonableComputation")
```

## **Use updateMask() instead of mask()** {-}

The difference between `updateMask()` and `mask()` is that the former does a logical `and()` of the argument (the new mask) and the existing image mask whereas `mask()` simply replaces the image mask with the argument. The danger of the latter is that you can unmask pixels unintentionally. In this example, the goal is to mask pixels less than or equal to 300 meters elevation. As you can see (zoom out), using `mask()` causes a lot of pixels to become unmasked, pixels that don't belong in the image of interest:

```{r}
l8sr <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")
sf <- ee$Geometry$Point(c(-122.40554461769182, 37.786807309873716))
aw3d30 <- ee$Image("JAXA/ALOS/AW3D30_V1_1")
Map$centerObject(sf, 7)
image <- l8sr$filterBounds(sf)$filterDate("2019-06-01", "2019-12-31")$first()
vis <- list(bands = c("B4", "B3", "B2"), min = 0, max = 3000)
Map$addLayer(image, vis, "image", FALSE)
mask <- aw3d30$select("AVE")$gt(300)
Map$addLayer(mask, {}, 'mask', FALSE)
# NO!  Don't do this!
badMask <- image$mask(mask)
Map$addLayer(badMask, vis, "badMask")
goodMask <- image.updateMask(mask)
Map$addLayer(goodMask, vis, "goodMask", FALSE)
```

## **Combine reducers** {-}

If you need multiple statistics (e.g. mean and standard deviation) from a single input (e.g. an image region), it is more efficient to combine reducers. For example, to get image statistics, combine reducers as follows:

```{r}
image <- ee$Image('COPERNICUS/S2/20150821T111616_20160314T094808_T30UWU')
# Get mean and SD in every band by combining reducers.
stats <- image$reduceRegion(
  reducer = ee$Reducer$mean()$combine(
    reducer2 = ee$Reducer$stdDev(),
    sharedInputs = TRUE
  ),
  geometry = ee$Geometry$Rectangle(c(-2.15, 48.55, -1.83, 48.72)),
  scale = 10,
  bestEffort = TRUE # Use maxPixels if you care about scale.
)
print(stats$getInfo())
# Extract means and SDs to images.
meansImage <- stats$toImage()$select('.*_mean')
sdsImage <- stats$toImage()$select('.*_stdDev')
```

In this example, note that the mean reducer is combined with the standard deviation reducer and `sharedInputs` is true to enable a single pass through the input pixels. In the output dictionary, the name of the reducer is appended to the band name. To get mean and SD images (for example to normalize the input image), you can turn the values into an image and use regexes to extract means and SDs individually as demonstrated in the example.

## **Use Export** {-}

For computations that result in "User memory limit exceeded" or "Computation timed out" errors in the Code Editor, the same computations may be able to succeed by using `Export`. This is because the timeouts are longer and the allowable memory footprint is larger when running in the batch system (where exports run). (There are other approaches you may want to try first as detailed in the debugging doc). Continuing the previous example, suppose that dictionary returned an error. You could obtain the results by doing something like:

```{r}
link <- '86836482971a35a5e735a17e93c23272'
task <- ee$batch$Export$table$toDrive(
  collection = ee$FeatureCollection(ee$Feature(NULL, stats)),
  description = paste0("exported_stats_demo_", link),
  fileFormat = "CSV"
)
# Using rgee I/O
task <- ee_table_to_drive(
  collection = ee$FeatureCollection(ee$Feature(NULL, stats)),
  description = paste0("exported_stats_demo_", link),
  fileFormat = "CSV"
)
task$start()
ee_monitoring(task)
exported_stats <- ee_drive_to_local(task = task,dsn = "exported_stats.csv")
read.csv(exported_stats)
```


Note that the link is embedded into the asset name, for reproducibility. Also note that if you want to export `toAsset`, you will need to supply a geometry, which can be anything, for example the image centroid, which is small and cheap to compute. (i.e. don't use a complex geometry if you don't need it).

See the debugging page for examples of using `Export` to resolve [Computation](https://developers.google.com/earth-engine/guides/debugging) timed out and [Too many concurrent aggregations](https://developers.google.com/earth-engine/guides/debugging). See [this doc](https://developers.google.com/earth-engine/guides/exporting) for details on exporting in general.

## **If you don't need to clip, don't use clip() ** {-}

Using `clip()` unnecessarily will increase computation time. Avoid `clip()` unless it's necessary to your analysis. If you're not sure, don't clip. An example of a bad use of clip:

<img src="images/thumb_down.png" width=25px>
&nbsp; **Bad** — Don't clip inputs unnecessarily!

```{r}
table <- ee$FeatureCollection('USDOS/LSIB_SIMPLE/2017')
l8sr <- ee$ImageCollection('LANDSAT/LC08/C01/T1_SR')
chad <- table$filter(ee$Filter$eq('country_na', 'Chad'))$first()
# Do NOT clip unless you need to.
unnecessaryClip <- l8sr$
  select('B4')$                           # Good.
  filterBounds(chad$geometry())$          # Good.
  filterDate('2019-01-01', '2019-12-31')$ # Good.
  map(function(image) {
    image$clip(chad$geometry())   # NO! Bad! Not necessary.
  })$
  median()$
  reduceRegion(
    reducer = ee$Reducer$mean(),
    geometry = chad$geometry(),
    scale = 30,
    maxPixels = 1e10
  )
print(unnecessaryClip$getInfo())
```

Clipping the input images can be skipped entirely, because the region is specified in the `reduceRegion()` call:

<img src="images/thumb_up.png" width=25px>
&nbsp; **Good** — Specify the region on the output.

```{r}
noClipNeeded <- l8sr$
  select('B4')$                          # Good.
  filterBounds(chad$geometry())$          # Good.
  filterDate('2019-01-01', '2019-12-31')$ # Good.
  median()$
  reduceRegion(
    reducer = ee$Reducer$mean(),
    geometry = chad$geometry(), # Geometry is specified here.
    scale = 30,
    maxPixels = 1e10
  )
print(noClipNeeded$getInfo())
```

If this computation times out, `Export` it as in [this example](https://developers.google.com/earth-engine/guides/best_practices).

## **If you need to clip with a complex collection, use clipToCollection()** {-}

If you really need to clip something, and the geometries you want to use for clipping are in a collection, use `clipToCollection()`:

```{r}
ecoregions <- ee$FeatureCollection('RESOLVE/ECOREGIONS/2017')
image <- ee$Image('JAXA/ALOS/AW3D30_V1_1')
complexCollection <- ecoregions$
  filter(
    ee$Filter$eq(
      'BIOME_NAME',
      'Tropical & Subtropical Moist Broadleaf Forests'
    )
  )
Map$addLayer(complexCollection, {}, 'complexCollection')
clippedTheRightWay <- image$select('AVE')$
  clipToCollection(complexCollection)
Map$addLayer(clippedTheRightWay, {}, 'clippedTheRightWay', FALSE)
```

Do NOT use `featureCollection.geometry()` or `featureCollection.union()` on 
large and/or complex collections, which can be more memory intensive.

## **Don't use a complex collection as the region for a reducer** {-}

If you need to do a spatial reduction such that the reducer pools inputs from multiple regions in a `FeatureCollection`, don't supply `featureCollection.geometry()` as the `geometry` input to the reducer. Instead, use `clipToCollection()` and a region large enough to encompass the bounds of the collection. For example:


```{r}
ecoregions <- ee$FeatureCollection('RESOLVE/ECOREGIONS/2017')
image <- ee$Image('JAXA/ALOS/AW3D30_V1_1')
complexCollection <- ecoregions$filter(
  ee$Filter$eq('BIOME_NAME', 'Tropical & Subtropical Moist Broadleaf Forests')
)
clippedTheRightWay <- image$select('AVE')$clipToCollection(complexCollection)
Map$addLayer(clippedTheRightWay, {}, 'clippedTheRightWay')
reduction <- clippedTheRightWay$reduceRegion(
  reducer = ee$Reducer$mean(),
  geometry = ee$Geometry$Rectangle(
    coords = c(-179.9, -50, 179.9, 50),  # Almost global.
    geodesic = FALSE
  ),
  scale = 30,
  maxPixels = 1e12
)
print(reduction$getInfo()) # If this times out, export it.
```

## **Use a non-zero errorMargin** {-}

For possibly expensive geometry operations, use the largest error margin possible given the required precision of the computation. The error margin specifies the maximum allowable error (in meters) permitted during operations on geometries (e.g. during reprojection). Specifying a small error margin can result in the need to densify geometries (with coordinates), which can be memory intensive. It's good practice to specify as large an error margin as possible for your computation:

```{r}
ecoregions <- ee$FeatureCollection("RESOLVE/ECOREGIONS/2017")
complexCollection <- ecoregions$limit(10)
Map$centerObject(complexCollection)
Map$addLayer(complexCollection)
expensiveOps <- complexCollection$map(function(f) {
  f$buffer(10000, 200)$bounds(200)
})
Map$addLayer(expensiveOps, {}, 'expensiveOps')
```


## **Don't use a ridiculously small scale with reduceToVectors()** {-}

If you want to convert a raster to a vector, use an appropriate scale. Specifying a very small scale can substantially increase computation cost. Set scale as high as possible give the required precision. For example, to get polygons representing global land masses:

```{r}
etopo <- ee$Image('NOAA/NGDC/ETOPO1')
# Approximate land boundary.
bounds <- etopo$select(0)$gt(-100)
# Non-geodesic polygon.
almostGlobal <- ee$Geometry$Polygon(
  coords = list(
    c(-180, -80),
    c(180, -80),
    c(180, 80),
    c(-180, 80),
    c(-180, -80)
  ),
  proj = "EPSG:4326",
  geodesic = FALSE
)
Map$addLayer(almostGlobal, {}, "almostGlobal")
vectors <- bounds$selfMask()$reduceToVectors(
  reducer = ee$Reducer$countEvery(),
  geometry = almostGlobal,
  # Set the scale to the maximum possible given
  # the required precision of the computation.
  scale = 50000
)
Map$addLayer(vectors, {}, "vectors")
```
In the previous example, note the use of a non-geodesic polygon for use in global reductions.

## **Don't use reduceToVectors() with reduceRegions()** {-}

Don't use a `FeatureCollection` returned by `reduceToVectors()` as an input to `reduceRegions()`. Instead, add the bands you want to reduce before calling `reduceToVectors()`:

```{r}
etopo <- ee$Image('NOAA/NGDC/ETOPO1')
mod11a1 <- ee$ImageCollection('MODIS/006/MOD11A1')
# Approximate land boundary.
bounds <- etopo$select(0)$gt(-100)
# Non-geodesic polygon.
almostGlobal <- ee$Geometry$Polygon(
  coords = list(c(-180, -80), c(180, -80), c(180, 80), c(-180, 80), c(-180, -80)),
  proj = "EPSG:4326",
  geodesic = FALSE
)
lst <- mod11a1$first()$select(0)
means <- bounds$selfMask()$addBands(lst)$reduceToVectors(
  reducer = ee$Reducer$mean(),
  geometry = almostGlobal,
  scale = 1000,
  maxPixels = 1e10
)
print(means$limit(10)$getInfo())
```

Note that other ways of reducing pixels of one image within zones of another include [reduceConnectedCommponents()](https://developers.google.com/earth-engine/api_docs#ee.image.reduceconnectedcomponents/) and/or [grouping reducers](https://developers.google.com/earth-engine/api_docs#ee.image.reduceconnectedcomponents/).

## **Use fastDistanceTransform() for neighborhood operations** {-}

For some convolution operations, `fastDistanceTransform()` may be more efficient than `reduceNeighborhood()` or `convolve()`. For example, to do erosion and/or dilation of binary inputs:

```{r}
aw3d30 <- ee$Image("JAXA/ALOS/AW3D30_V1_1")
# Make a simple binary layer from a threshold on elevation.
mask <- aw3d30$select("AVE")$gt(300)
Map$setCenter(-122.0703, 37.3872, 11)
Map$addLayer(mask, {}, "mask")
# Distance in pixel units.
distance <- mask$fastDistanceTransform()$sqrt()
# Threshold on distance (three pixels) for a dilation.
dilation <- distance$lt(3)
Map$addLayer(dilation, {}, "dilation")
# Do the reverse for an erosion.
notDistance <- mask$Not()$fastDistanceTransform()$sqrt()
erosion <- notDistance$gt(3)
Map$addLayer(erosion, {}, 'erosion')
```

## **Use the optimizations in reduceNeighborhood()** {-}

If you need to perform a convolution and can't use `fastDistanceTransform()`, use the optimizations in `reduceNeighborhood()`.

```{r}
l8raw <- ee$ImageCollection('LANDSAT/LC08/C01/T1_RT')
composite <- ee$Algorithms$Landsat$simpleComposite(l8raw)
bands <- c('B4', 'B3', 'B2')
optimizedConvolution <- composite$select(bands)$reduceNeighborhood(
  reducer = ee$Reducer$mean(),
  kernel = ee$Kernel$square(3),
  optimization = "boxcar" # Suitable optimization for mean.
)$rename(bands)
viz <- list(bands = bands, min = 0, max = 72)
Map$setCenter(-122.0703, 37.3872, 11)
Map$addLayer(composite, viz, "composite") +
Map$addLayer(optimizedConvolution, viz, "optimizedConvolution")
```

## **Don't sample more data than you need** {-}

Resist the urge to increase your training dataset size unnecessarily. Although increasing the amount of training data is an effective machine learning strategy in some circumstances, it can also increase computational cost with no corresponding increase in accuracy. (For an understanding of when to increase training dataset size, see [this reference](https://www.deeplearning.ai/programs/)). The following example demonstrates how requesting too much training data can result in the dreaded "Computed value is too large" error:

<img src="images/thumb_down.png" width=25px>
&nbsp; **Bad** — Don't sample too much data!

```{r}
l8raw <- ee$ImageCollection('LANDSAT/LC08/C01/T1_RT')
composite <- ee$Algorithms$Landsat$simpleComposite(l8raw)
labels <- ee$FeatureCollection('projects/google/demo_landcover_labels')
# No!  Not necessary.  Don't do this:
labels <- labels$map(function(f){f$buffer(100000, 1000)})
bands <- c('B2', 'B3', 'B4', 'B5', 'B6', 'B7')
training <- composite$select(bands)$sampleRegions(
  collection = labels,
  properties = list("landcover"),
  scale = 30
)
classifier <- ee$Classifier$smileCart()$train(
  features = training,
  classProperty = "landcover",
  inputProperties = bands
)
print(classifier$explain()) # Computed value is too large
```

The better approach is to start with a moderate amount of data and tune the hyperparameters of the classifier to determine if you can achieve your desired accuracy:

<img src="images/thumb_up.png" width=25px>
&nbsp; **Good** — Tune hyperparameters.

```{r}
l8raw <- ee$ImageCollection("LANDSAT/LC08/C01/T1_RT")
composite <- ee$Algorithms$Landsat$simpleComposite(l8raw)
labels <- ee$FeatureCollection("projects/google/demo_landcover_labels")
# Increase the data a little bit, possibly introducing noise.
labels <- labels$map(function(f) {f$buffer(100, 10)})
bands <- c('B2', 'B3', 'B4', 'B5', 'B6', 'B7')
data <- composite$select(bands)$sampleRegions(
  collection = labels,
  properties = list("landcover"),
  scale = 30
)
# Add a column of uniform random numbers called 'random'.
data <- data$randomColumn()
# Partition into training and testing.
training <- data$filter(ee$Filter$lt("random", 0.5))
testing <- data$filter(ee$Filter$gte("random", 0.5))
# Tune the minLeafPopulation parameter.
minLeafPops <- ee$List$sequence(1, 10)
accuracies <- minLeafPops$map(
  ee_utils_pyfunc(
    function(p) {
      classifier <- ee$Classifier$smileCart(minLeafPopulation = p)$
        train(
          features = training,
          classProperty = "landcover",
          inputProperties = bands
        )
      
      testing$
        classify(classifier)$
        errorMatrix("landcover", "classification")$
        accuracy()
    }
  )
)
minLeafPopulation_array <- accuracies$getInfo()
plot(
  x = minLeafPopulation_array,
  type = "b", 
  col = "blue",
  lwd = 2,
  ylab = "accuracy",
  xlim = c(0,10),
  xlab = "value",
  main = "Hyperparameter tunning (minLeafPopulation)"
)
```

In this example, the classifier is already very accurate, so there's not much tuning to do. You might want to choose the smallest tree possible (i.e. largest `minLeafPopulation`) that still has the required accuracy.

## **Export intermediate results** {-}

Suppose your objective is to take samples from a relatively complex computed image. It is often more efficient to `Export` the image `toAsset()`, load the exported image, then sample. For example:

```{r}
image <- ee$Image('UMD/hansen/global_forest_change_2018_v1_6')
geometry <- ee$Geometry$Polygon(
  coords = list(
    c(-76.64069800085349, 5.511777325802095),
    c(-76.64069800085349, -20.483938229362376),
    c(-35.15632300085349, -20.483938229362376),
    c(-35.15632300085349, 5.511777325802095)
  ),
  proj =  "EPSG:4326",
  geodesic =  FALSE
)
testRegion <- ee$Geometry$Polygon(
  coords = list(
    c(-48.86726050085349, -3.0475996402515717),
    c(-48.86726050085349, -3.9248707849303295),
    c(-47.46101050085349, -3.9248707849303295),
    c(-47.46101050085349, -3.0475996402515717)
  ),
  proj = "EPSG:4326",
  geodesic = FALSE
)
# Forest loss in 2016, to stratify a sample.
loss <- image$select("lossyear")
loss16 <- loss$eq(16)$rename("loss16")
# Cloud masking function.
maskL8sr <- function(image) {
  cloudShadowBitMask <- bitwShiftL(1, 3)
  cloudsBitMask <- bitwShiftL(1, 5)
  qa <- image$select('pixel_qa')
  mask <- qa$bitwiseAnd(cloudShadowBitMask)$eq(0)$
    And(qa$bitwiseAnd(cloudsBitMask)$eq(0))
  
  image$updateMask(mask)$
    divide(10000)$
    select("B[0-9]*")$
    copyProperties(image, list("system:time_start"))
}
collection <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")$map(maskL8sr)
# Create two annual cloud-free composites.
composite1 <- collection$filterDate('2015-01-01', '2015-12-31')$median()
composite2 <- collection$filterDate('2017-01-01', '2017-12-31')$median()
# We want a strtatified sample of this stack.
stack <- composite1$addBands(composite2)$float() # Export the smallest size possible.
# Export the image.  This block is commented because the export is complete.
# link <- "0b8023b0af6c1b0ac7b5be649b54db06"
# desc <- paste0(ee_get_assethome(), "/Logistic_regression_stack_", link)
# 
# #ee_image_info(stack)
# task <- ee_image_to_asset(
#   image = stack,
#   description = link,
#   assetId = desc,
#   region = geometry,
#   scale = 100,
#   maxPixels = 1e10
# )
  
# Load the exported image.
exportedStack <- ee$Image(
  "projects/google/Logistic_regression_stack_0b8023b0af6c1b0ac7b5be649b54db06"
)
# Take a very small sample first, to debug.
testSample <- exportedStack$addBands(loss16)$stratifiedSample(
  numPoints = 1,
  classBand = "loss16",
  region = testRegion,
  scale = 30,
  geometries = TRUE
)
print(testSample$getInfo()) # Check this in the console.
# Take a large sample.
sample <- exportedStack$addBands(loss16)$stratifiedSample(
  numPoints = 10000,
  classBand = "loss16",
  region = geometry,
  scale = 30
)
# Export the large sample...
```

In this example, note that the imagery is exported as float. Don't export at double precision unless absolutely necessary.

Once the export is completed, reload the asset and proceed with sampling from it. Note that a very small sample over a very small test area is run first, for debugging. When that is shown to succeed, take a larger sample and export it. Such large samples typically need to be exported. Do not expect such samples to be available interactively (for example through `print()`) or useable (for example as input to a classifier) without exporting them first.

## **Join vs. map-filter** {-}

Suppose you want to join collections based on time, location or some metadata property. Generally, this is most efficiently accomplished with a join. The following example does a spatio-temporal join between the Landsat 8 and Sentinel-2 collections:

```{r}
s2 <- ee$ImageCollection("COPERNICUS/S2")$
  filterBounds(ee$Geometry$Point(c(-2.0205, 48.647)))
l8 <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")
joined <- ee$Join$saveAll("landsat")$apply(
  primary = s2,
  secondary = l8,
  condition = ee$Filter$And(
    ee$Filter$maxDifference(
      difference = 1000 * 60 * 60 * 24, # One day in milliseconds
      leftField = "system:time_start",
      rightField = "system:time_start"
    ),
    ee$Filter$intersects(
      leftField = ".geo",
      rightField = ".geo"
    )
  )
)
print(joined$first()$getInfo())
```

Although you should try a join first (`Export` if needed), occasionally a `filter()` within a `map()` can also be effective, particularly for very large collections.


```{r}
s2 <- ee$ImageCollection("COPERNICUS/S2")$
  filterBounds(ee$Geometry$Point(c(-2.0205, 48.647)))
l8 <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")
mappedFilter <- s2$map(function(image) {
  date <- image$date()
  landsat <- l8$
    filterBounds(image$geometry())$
    filterDate(date$advance(-1, "day"), date$advance(1, "day"))
    # Return the input image with matching scenes in a property.
  image$set(
    list(
      landsat = landsat,
      size = landsat$size()
    )
  )
})$filter(ee$Filter$gt("size", 0))
print(mappedFilter$first()$getInfo())
```


## **reduceRegion() vs. reduceRegions() vs. for-loop** {-}

Calling `reduceRegions()` with a very large or complex
`FeatureCollection` as input may result in the dreaded “Computed value
is too large” error. One potential solution is to map `reduceRegion()`
over the `FeatureCollection` instead. Another potential solution is to
use a (gasp) for-loop. Although this is strongly discouraged in Earth
Engine as described [here](https://developers.google.com/earth-engine/guides/getstarted), [here](https://developers.google.com/earth-engine/tutorials/tutorial_js_03) and [here](https://developers.google.com/earth-engine/guides/client_server), `reduceRegion()` can be implemented in a for-loop to perform large reductions.

Suppose your objective is to obtain the mean of pixels (or any statistic) in each feature in a `FeatureCollection` for each image in an `ImageCollection`. The following example compares the three approaches previously described:

```{r}
# Table of countries.
countriesTable <- ee$FeatureCollection("USDOS/LSIB_SIMPLE/2017")
# Time series of images.
mod13a1 <- ee$ImageCollection("MODIS/006/MOD13A1")
# MODIS vegetation indices (always use the most recent version).
band <- "NDVI"
imagery <- mod13a1$select(band)
# Option 1: reduceRegions()
testTable <- countriesTable$limit(1) # Do this outside map()s and loops.
data <- imagery$map(function(image) {
  image$reduceRegions(
    collection = testTable,
    reducer = ee$Reducer$mean(),
    scale = 500
  )$map(function(f) {
    f$set(
      list(
        time = image$date()$millis(),
        date = image$date()$format()
      )
    )
  })
})$flatten()
print(data$first()$getInfo())
# Option 2: mapped reduceRegion()
data <- countriesTable$map(function(feature) {
  imagery$map(
    function(image) {
      ee$Feature(
        feature$geometry()$centroid(100),
        image$reduceRegion(
          reducer = ee$Reducer$mean(),
          geometry = feature$geometry(),
          scale = 500
        )
      )$set(
        list(
          time = image$date()$millis(),
          date = image$date()$format()
        )
      )$copyProperties(feature)
    }
  )
})$flatten()
print(data$first()$getInfo())
# Option 3: for-loop (WATCH OUT!)
size <- countriesTable$size()
print(size$getInfo()) # 312
countriesList <- countriesTable$toList(1) # Adjust size.
data <- ee$FeatureCollection(list()) # Empty table.
for (j in (seq_len(countriesList$length()$getInfo()) - 1)) {
  feature <- ee$Feature(countriesList$get(j))
  # Convert ImageCollection > FeatureCollection
  fc <- ee$FeatureCollection(
    imagery$map(
      function(image) {
        ee$Feature(
          feature$geometry()$centroid(100),
          image$reduceRegion(
            reducer = ee$Reducer$mean(),
            geometry = feature$geometry(),
            scale = 500
          )
        )$set(
          list(
            time = image$date()$millis(),
            date = image$date()$format()
          )
        )$copyProperties(feature)
      }
    )
  )
  data <- data$merge(fc)
}
print(data$first()$getInfo())
```

Note that the `first()` thing from each collection is printed, for debugging purposes. You should not expect that the complete result will be available interactively: you'll need to `Export`. Also note that for-loops should be used with extreme caution and only as a last resort. Finally, the for-loop requires manually obtaining the size of the input collection and hardcoding that in the appropriate locations. If any of that sounds unclear to you, don't use a for-loop.

## **Use forward differencing for neighbors in time** {-}

Suppose you have a temporally sorted `ImageCollection` (i.e. a time series) and you want to compare each image to the previous (or next) image. Rather than use `iterate()` for this purpose, it may be more efficient to use an array-based forward differencing. The following example uses this method to de-duplicate the Sentinel-2 collection, where duplicates are defined as images with the same day of year:

```{r}
sentinel2 <- ee$ImageCollection("COPERNICUS/S2")
sf <- ee$Geometry$Point(c(-122.47555371521855, 37.76884708376152))
s2 <- sentinel2$
  filterBounds(sf)$
  filterDate("2018-01-01", "2019-12-31")
withDoys <- s2$map(function(image) {
  ndvi <- image$normalizedDifference(c("B4", "B8"))$rename("ndvi")
  date <- image$date()
  doy <- date$getRelative("day", "year")
  time <- image$metadata("system:time_start")
  doyImage <- ee$Image(doy)$
    rename("doy")$
    int()
  
  ndvi$
    addBands(doyImage)$
    addBands(time)$
    clip(image$geometry()) # Appropriate use of clip.
})
array <- withDoys$toArray()
timeAxis <- 0
bandAxis <- 1
dedup <- function(array) {
  time <- array$arraySlice(bandAxis, -1)
  sorted <- array$arraySort(time)
  doy <- sorted$arraySlice(bandAxis, -2, -1)
  left <- doy$arraySlice(timeAxis, 1)
  right <- doy$arraySlice(timeAxis, 0, -1)
  mask <- ee$Image(ee$Array(list(list(1))))$
    arrayCat(left$neq(right), timeAxis)
  array$arrayMask(mask)
}
deduped <- dedup(array)
# Inspect these outputs to confirm that duplicates have been removed.
print(array$reduceRegion("first", sf, 10)$getInfo())
print(deduped$reduceRegion("first", sf, 10)$getInfo())
```


# Debugging {-}

Earth Engine is unlike traditional image processing, GIS or other desktop software used for geospatial data analysis. Algorithms you create in Earth Engine run in the Google cloud, distributed over many computers. Debugging can be challenging because errors can occur either in the client-side JavaScript code or the server-side execution of the coded instructions, and result from scaling problems as well as syntactic or logical errors. The bits of the program that are running somewhere in the cloud are not available to inspect, unless you ask for them. This document presents debugging strategies, tools and solutions to help you resolve common errors and debug Earth Engine scripts.


## Client-side errors {-}

Despite syntactically correct JavaScript, there may be errors associated with the consistency or logic of the script. The following examples demonstrate errors from using a variable and method that don't exist:

<img src="images/thumb_down.png" width=25px>
&nbsp; **Error** — This code doesn't work!

```{r}
# Load a Sentinel-2 image.
image <- ee$Image('USGS/SRTMGL1_003')

display <- image$visualize(list(bands = bandNames, min = 0, max = 9000))
# Error in py_resolve_dots(list(...)) : object 'bandNames' not found

# Error: image.selfAnalyze is not a function
silly <- image$selfAnalyze()
# Error in py_get_attr_impl(x, name, silent) : AttributeError: 'Image' object has no attribute 'selfAnalyze'
```

The first error informs you that the `bandNames` variable is not defined in the scope in which it's referenced. As a solution, set the variable, or provide a list argument for the `bands` parameter. The second error demonstrates what happens when the non-existent `selfAnalyze()` function is called. Since that isn't a real method on images, the error tells you it's not a function. In both cases, the error is descriptive of the problem.


## Casting {-}

The "`...is not a function`" error may result from Earth Engine not knowing the type of a variable. Common manifestations of this problem result from:

- Doing something to an object returned by `first()` (the type of the elements in a collection is unknown).

- Doing something to an object returned by `get()` (the type of element stored in a property is unknown).

- Doing something to a function argument (in the function) when the type of the argument is unknown.
For an example of the former:

<img src="images/thumb_down.png" width=25px>
&nbsp; **Error** — This code doesn't work!

```{r}
collection <- ee$ImageCollection('MODIS/051/MOD44B')

date <- collection$first()$date()
# Error: collection$first(...).date is not a function
```

The solution in all cases is to cast the object of unknown type with the constructor of the known type. Continuing the previous example, the solution is to cast to `ee$Image`:

<img src="images/thumb_up.png" width=25px>
&nbsp; **Good** — Use a cast!

```{r}
date <- ee$Image(collection$first())$date()
```

(It's worth noting that you can safely call any method on `Element` here because that's what Earth Engine thinks it is).

## Avoid mixing client and server functions {-}

The following example is less obvious:

<img src="images/thumb_down.png" width=25px>
&nbsp; **Error** — this code doesn't do what you want

```{r}
# Don't mix EE objects and JavaScript objects:
image <- ee$Image('USGS/SRTMGL1_003')
nonsense <- image + 2

# You can print this, but it's not what you were hoping for.
print(nonsense)

# Error: g.eeObject.name is not a function
Map$addLayer(nonsense)
```

Supposing the author of this code intended to add `2` to every pixel in the image, this is not the right way to do it. Specifically, this code wrongly mixes a server-side object (`image`) with a client-side JavaScript operator (`+`). The results may be surprising. In the first case, printing of `nonsense`, JavaScript will perform the requested operation (`+`) by converting both `image` and `2` to strings, then concatenating them. The resultant string is unintended. In the second case, adding nonsense to the map, the cryptic `g.eeObject.name` is not a function error is displayed because the object being added to the map, `nonsense`, is a string, not an EE object. To avoid possibly unintended results and uninformative errors, don't mix server objects and functions with JavaScript objects, primitives or functions. The solution is this example is to use a server function:

<img src="images/thumb_up.png" width=25px>
&nbsp; **Good** —  use a server function!

```{r}
Map$addLayer(image$add(2))
```

For more detailed explanation of client vs. server in Earth Engine, see [this page]() and/or [this tutorial]().

## Server-side errors {-}

Despite logical consistency in the client JavaScript, there may be bugs which only become apparent at run time on the server. The following example demonstrates what happens when trying to get a band that doesn't exist:

<img src="images/thumb_down.png" width=25px>
&nbsp; **Error** — this code doesn't work!

```{r}
# Load a Sentinel-2 image.
s2image <- ee$Image('COPERNICUS/S2/20160625T100617_20160625T170310_T33UVR')

ee_print(s2image$select('nonBand'))
# Error in py_call_impl(callable, dots$args, dots$keywords) : EEException: Image.select: Pattern 'nonBand' did not match any bands.
```

In this example, the error informs you that there is no band named `nonBand`. The possibly obvious solution is to specify a band name that does exist. You can discover the band names by printing the image and inspecting it in the console, or by printing the list of band names returned by `image.bandNames()`.

## Immutability {-}

Server-side objects you create in Earth Engine are [immutable](https://en.wikipedia.org/wiki/Immutable_object). (Any ee$Object is a server side Object). That means that if you want to make a change to the object, you have to save the changed state into a new variable. For example, this won't work to set a property on the Sentinel-2 image:

<img src="images/thumb_down.png" width=25px>
&nbsp; **Error** — this code doesn't do what you want!


```{r}
s2image <- ee$Image('COPERNICUS/S2/20160625T100617_20160625T170310_T33UVR')
s2image$set('myProperty', 'This image is not assigned to a variable');

# This will not result in an error, but will not find 'myProperty'.
print(s2image$get('myProperty')$getInfo()) # NULL
```


In this example, `s2image$set()` returns a copy of the image with the new property, but the image stored in the s2image variable is unchanged. You need to save the image returned by `s2image$set()` in a new variable. For example:

<img src="images/thumb_up.png" width=25px>
&nbsp; **Good** —  capture the result in a variable!

```{r}
s2image = s2image$set('myProperty', 'OK')
print(s2image$get('myProperty')$getInfo()) # OK
```

## Mapped functions {-}

Another context in which client and server functions don't mix is in mapped functions. Specifically, the operations specified by the mapped function run in the cloud, so client functions such as `print()`, `getInfo()` or any method on `Map`, or `Export` won't work in mapped functions. For example:

<img src="images/thumb_down.png" width=25px>
&nbsp; **Error** — this code doesn't work!

```{r}
collection <- ee$ImageCollection('MODIS/051/MOD44B')

# Error: A mapped function's arguments cannot be used in client-side operations
badMap3 <- collection$map(function(image) {
  print(image$getInfo())
  return(image)
})
```

This somewhat cryptic error results from the process Earth Engine uses to turn this code into a set of instructions that can be run on Google servers. Specifically, it means that Earth Engine can't find a server-side function called `print()`, because there isn't one. More generally, client-side functions and control structures cannot be used to operate on the argument image passed to the mapped function. To avoid this error, avoid the use of client-side functions in mapped functions. See [this page]() to learn more about the distinction between client and server functions.

Mapped functions have additional requirements, all of which must be met to avoid errors. For example, mapped functions must return something. Although the Code Editor detects this problem and issues the error, it is specific to mapped functions that run on the server:

<img src="images/thumb_down.png" width=25px>
&nbsp; **Error** —  this code doesn't work!

```{r}
collection <- ee$ImageCollection('MODIS/051/MOD44B')

# Error: User-defined methods must return a value.
badMap1 <- collection$map(function(image) {
  # Do nothing.
})
```

The possibly obvious solution is to return something. But it can't return just any type of thing. Specifically, functions mapped over an `ImageCollection` or `FeatureCollection` must return an `Image` or `Feature`. For example, you can't return a date from a function mapped over an `ImageCollection`:

<img src="images/thumb_down.png" width=25px>
&nbsp; **Error** —  this code doesn't work!

```{r}
collection <- ee$ImageCollection('MODIS/006/MOD44B')

badMap2 <- collection$map(function(image) {
  return(image$date())
})

print(badMap2$getInfo())
# Error: Collection.map: A mapped algorithm must return a Feature or Image.
```

To avoid this, return the input image with a new property set. Then, if you need a list of the dates of the images in the collection, you can use `aggregate_array()`:

<img src="images/thumb_up.png" width=25px>
&nbsp; **Good** —  set a property!

```{r}
collection <- ee$ImageCollection('MODIS/006/MOD44B')

okMap2 <- collection$map(function(image) {
  image$set('date', image$date())
})
ee_print(okMap2)

# Get a list of the dates.
datesList <- okMap2$aggregate_array('date')
datesList$getInfo()
```


